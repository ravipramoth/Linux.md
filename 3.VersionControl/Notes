# Git notes (updated: 2025-08-12)

What is version Control  ? 

Version control is a system that records changes to files or sets of files over time so that you can recall specific versions later. 
It allows multiple people to collaborate on projects, track changes, and revert to previous states if necessary.

Types of version contorl ?


  Github -- It place where you can host your code on Cloud (bitbucet, azure repo, Aws Code commit, gitlab,github)

To install git in windows 


https://git-scm.com/downloads/win

for other operating system

https://git-scm.com/downloads 

GUI - Git 

https://www.gitkraken.com/download/windows64 

Working ( current directrory )
Stagging Area ( index )
commit 



## Quick setup (first time)
- Identity
  - git config --global user.name "Pramoth"
  - git config --global user.email "ravipramoth@gmail.com"
- Defaults
  - git config --global init.defaultBranch main
  - Verify: git config --list

## Create or clone
- git init


## File lifecycle
- git status (or: git status -s)
- git add <file>  |  git add .
- git commit -m "message"
- git log --oneline --graph --decorate --all
- git show
- git diff
- git diff --staged  # It will show the changes of file between working and stagging ares 
  - git diff <A> <B> -- <path>

## Branches
- git branch
- git switch -c feature/x   (or: git checkout -b feature/x) # It will create the branch and Jump to that barnch 
- git switch feature/x
- git branch -m new-name
- git branch -d old-branch  (or: -D to force) # delete the branch that not requried 

## Merge
- git switch main
- git merge feature/x
- Keep merge commit: git merge --no-ff feature/x
Refer to Notes.md for the formatted Git cheat sheet.

PR -- Pull request or merge 




# clean untracked files/dirs
git clean -fd

# recover using reflog (find lost commits/branches)
git reflog


# Bisect (find first bad commit)
# start a bisection session
git bisect start
git bisect bad                 # mark current as bad
git bisect good <good-sha>     # mark a known good commit
# Git checks out a midpoint → test your app →
#   if bad:  git bisect bad
#   if good: git bisect good
# repeat until Git prints the first bad commit
git bisect reset               # end session


# .gitignore tips (examples)
# Logs
logs/
*.log
!keep.me

# OS/editor
.DS_Store
Thumbs.db
.vscode/

# Dependencies
node_modules/
venv/

# Builds
dist/
build/


# Everyday workflow example
# create a branch, work, rebase on latest main, push PR
git switch -c feature/add-api
# edit files
git add .
git commit -m "feat: add API client"
git fetch origin
git rebase origin/main
git push -u origin feature/add-api
# after merge:
git switch main
git pull --ff-only
git branch -d feature/add-api


# Troubleshooting
# push rejected (non-fast-forward)
#   update local, reapply, push
git fetch origin
git rebase origin/main   # or: git pull --rebase
# resolve conflicts → continue → push

git switch -c rescue     # from detached HEAD to keep work

# restore a file from another branch
git restore -s origin/main -- path/to/file


Here are the **common branching strategies** used in software development and DevOps workflows. Each has its own pros, cons, and use cases:

---

## 1. **Mainline (Trunk-Based Development)**

* Developers commit directly to the main branch (`main`/`trunk`/`master`).
* Short-lived feature branches are allowed but merged back quickly (daily or multiple times a day).
* Encourages **Continuous Integration (CI)**.
* **Best for:** Agile teams, fast releases, DevOps environments.

---

## 2. **Feature Branching**

* Each feature is developed in its own branch from `main` or `develop`.
* After completion, merged back via Pull Request (PR) with code reviews.
* Provides **isolation** for features but can lead to long-lived branches if not disciplined.
* **Best for:** Teams using GitHub/GitLab PR workflows.

---

## 3. **Git Flow**

* A structured model with multiple long-lived branches:

  * `main` → production-ready code
  * `develop` → integration branch for features
  * `feature/*` → feature-specific work
  * `release/*` → pre-production stabilization
  * `hotfix/*` → urgent fixes in production
* Provides clear structure but may feel **heavyweight** for fast-moving teams.
* **Best for:** Enterprises, large teams, projects with defined release cycles.

---

## 4. **GitHub Flow**

* A **simplified version of Git Flow**:

  * Only `main` branch.
  * Create feature branch → work → open PR → review → merge → deploy.
* Focuses on **continuous delivery** and **small, frequent deployments**.
* **Best for:** Startups, cloud-native teams, SaaS products.

---

## 5. **Release Branching**

* Each release gets its own branch (e.g., `release-v1.0`, `release-v2.0`).
* Allows for **patching old versions** while developing new features.
* **Best for:** Products that need **long-term support (LTS)** or multiple versions in parallel.

---

## 6. **Environment Branching**

* Separate branches per environment (e.g., `dev`, `qa`, `staging`, `prod`).
* Code is promoted from lower → higher environments.
* Can cause **merge hell** if not managed properly.
* **Best for:** Legacy systems, organizations without CI/CD maturity.

---

## 7. **Forking Workflow**

* Developers fork the main repository, make changes in their fork, then submit a Pull Request.
* Common in **open-source projects** to enable contributions without giving direct write access.
* **Best for:** Open-source collaboration.

---
